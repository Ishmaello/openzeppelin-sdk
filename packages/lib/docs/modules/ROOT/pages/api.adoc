= API Reference

== Proxies

NOTE: Proxy contracts and their documentation have moved to xref:contracts:api:proxy.adoc[Contracts].

:ProxyFactory: pass:normal[xref:#ProxyFactory[`++ProxyFactory++`]]
:constructor: pass:normal[xref:#ProxyFactory-constructor--[`++constructor++`]]
:deployMinimal: pass:normal[xref:#ProxyFactory-deployMinimal-address-bytes-[`++deployMinimal++`]]
:deploy: pass:normal[xref:#ProxyFactory-deploy-uint256-address-address-bytes-[`++deploy++`]]
:deploySigned: pass:normal[xref:#ProxyFactory-deploySigned-uint256-address-address-bytes-bytes-[`++deploySigned++`]]
:getDeploymentAddress: pass:normal[xref:#ProxyFactory-getDeploymentAddress-uint256-address-[`++getDeploymentAddress++`]]
:getSigner: pass:normal[xref:#ProxyFactory-getSigner-uint256-address-address-bytes-bytes-[`++getSigner++`]]
:_deployProxy: pass:normal[xref:#ProxyFactory-_deployProxy-uint256-address-address-bytes-address-[`++_deployProxy++`]]
:_createProxy: pass:normal[xref:#ProxyFactory-_createProxy-uint256-address-[`++_createProxy++`]]
:_getSalt: pass:normal[xref:#ProxyFactory-_getSalt-uint256-address-[`++_getSalt++`]]
:ProxyCreated: pass:normal[xref:#ProxyFactory-ProxyCreated-address-[`++ProxyCreated++`]]

[.contract]
[[ProxyFactory]]
=== `++ProxyFactory++`




[.contract-index]
.Functions
--
* xref:#ProxyFactory-constructor--[`++constructor()++`]
* xref:#ProxyFactory-deployMinimal-address-bytes-[`++deployMinimal(_logic, _data)++`]
* xref:#ProxyFactory-deploy-uint256-address-address-bytes-[`++deploy(_salt, _logic, _admin, _data)++`]
* xref:#ProxyFactory-deploySigned-uint256-address-address-bytes-bytes-[`++deploySigned(_salt, _logic, _admin, _data, _signature)++`]
* xref:#ProxyFactory-getDeploymentAddress-uint256-address-[`++getDeploymentAddress(_salt, _sender)++`]
* xref:#ProxyFactory-getSigner-uint256-address-address-bytes-bytes-[`++getSigner(_salt, _logic, _admin, _data, _signature)++`]
* xref:#ProxyFactory-_deployProxy-uint256-address-address-bytes-address-[`++_deployProxy(_salt, _logic, _admin, _data, _sender)++`]
* xref:#ProxyFactory-_createProxy-uint256-address-[`++_createProxy(_salt, _sender)++`]
* xref:#ProxyFactory-_getSalt-uint256-address-[`++_getSalt(_salt, _sender)++`]

--

[.contract-index]
.Events
--
* xref:#ProxyFactory-ProxyCreated-address-[`++ProxyCreated(proxy)++`]

--


[.contract-item]
[[ProxyFactory-constructor--]]
==== `++constructor()++` [.item-kind]#public#



[.contract-item]
[[ProxyFactory-deployMinimal-address-bytes-]]
==== `++deployMinimal(++[.var-type]#++address++#++ ++[.var-name]#++_logic++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_data++#++) → ++[.var-type]#++address++#++ ++[.var-name]#++proxy++#++++` [.item-kind]#public#



[.contract-item]
[[ProxyFactory-deploy-uint256-address-address-bytes-]]
==== `++deploy(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_logic++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_admin++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_data++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#



[.contract-item]
[[ProxyFactory-deploySigned-uint256-address-address-bytes-bytes-]]
==== `++deploySigned(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_logic++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_admin++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_data++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_signature++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#



[.contract-item]
[[ProxyFactory-getDeploymentAddress-uint256-address-]]
==== `++getDeploymentAddress(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_sender++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#



[.contract-item]
[[ProxyFactory-getSigner-uint256-address-address-bytes-bytes-]]
==== `++getSigner(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_logic++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_admin++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_data++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_signature++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#



[.contract-item]
[[ProxyFactory-_deployProxy-uint256-address-address-bytes-address-]]
==== `++_deployProxy(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_logic++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_admin++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++_data++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_sender++#++) → ++[.var-type]#++address++#++++` [.item-kind]#internal#



[.contract-item]
[[ProxyFactory-_createProxy-uint256-address-]]
==== `++_createProxy(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_sender++#++) → ++[.var-type]#++contract InitializableAdminUpgradeabilityProxy++#++++` [.item-kind]#internal#



[.contract-item]
[[ProxyFactory-_getSalt-uint256-address-]]
==== `++_getSalt(++[.var-type]#++uint256++#++ ++[.var-name]#++_salt++#++, ++[.var-type]#++address++#++ ++[.var-name]#++_sender++#++) → ++[.var-type]#++bytes32++#++++` [.item-kind]#internal#




[.contract-item]
[[ProxyFactory-ProxyCreated-address-]]
==== `++ProxyCreated(++[.var-type]#++address++#++ ++[.var-name]#++proxy++#++)++` [.item-kind]#event#





== Application

:App: pass:normal[xref:#App[`++App++`]]
:onlyOwner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-onlyOwner--[`++onlyOwner++`]]
:constructor: pass:normal[xref:#App-constructor--[`++constructor++`]]
:getProvider: pass:normal[xref:#App-getProvider-string-[`++getProvider++`]]
:getPackage: pass:normal[xref:#App-getPackage-string-[`++getPackage++`]]
:setPackage: pass:normal[xref:#App-setPackage-string-contract-Package-uint64-3--[`++setPackage++`]]
:unsetPackage: pass:normal[xref:#App-unsetPackage-string-[`++unsetPackage++`]]
:getImplementation: pass:normal[xref:#App-getImplementation-string-string-[`++getImplementation++`]]
:create: pass:normal[xref:#App-create-string-string-address-bytes-[`++create++`]]
:owner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-owner--[`++owner++`]]
:isOwner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-isOwner--[`++isOwner++`]]
:renounceOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-renounceOwnership--[`++renounceOwnership++`]]
:transferOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-transferOwnership-address-[`++transferOwnership++`]]
:_transferOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-_transferOwnership-address-[`++_transferOwnership++`]]
:ProxyCreated: pass:normal[xref:#App-ProxyCreated-address-[`++ProxyCreated++`]]
:PackageChanged: pass:normal[xref:#App-PackageChanged-string-address-uint64-3--[`++PackageChanged++`]]
:OwnershipTransferred: pass:normal[xref:#OpenZeppelinUpgradesOwnable-OwnershipTransferred-address-address-[`++OwnershipTransferred++`]]

[.contract]
[[App]]
=== `++App++`

Contract for upgradeable applications.
It handles the creation of proxies.

[.contract-index]
.Modifiers
--

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-onlyOwner--[`++onlyOwner()++`]

--

[.contract-index]
.Functions
--
* xref:#App-constructor--[`++constructor()++`]
* xref:#App-getProvider-string-[`++getProvider(packageName)++`]
* xref:#App-getPackage-string-[`++getPackage(packageName)++`]
* xref:#App-setPackage-string-contract-Package-uint64-3--[`++setPackage(packageName, package, version)++`]
* xref:#App-unsetPackage-string-[`++unsetPackage(packageName)++`]
* xref:#App-getImplementation-string-string-[`++getImplementation(packageName, contractName)++`]
* xref:#App-create-string-string-address-bytes-[`++create(packageName, contractName, admin, data)++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-owner--[`++owner()++`]
* xref:#OpenZeppelinUpgradesOwnable-isOwner--[`++isOwner()++`]
* xref:#OpenZeppelinUpgradesOwnable-renounceOwnership--[`++renounceOwnership()++`]
* xref:#OpenZeppelinUpgradesOwnable-transferOwnership-address-[`++transferOwnership(newOwner)++`]
* xref:#OpenZeppelinUpgradesOwnable-_transferOwnership-address-[`++_transferOwnership(newOwner)++`]

--

[.contract-index]
.Events
--
* xref:#App-ProxyCreated-address-[`++ProxyCreated(proxy)++`]
* xref:#App-PackageChanged-string-address-uint64-3--[`++PackageChanged(providerName, package, version)++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-OwnershipTransferred-address-address-[`++OwnershipTransferred(previousOwner, newOwner)++`]

--


[.contract-item]
[[App-constructor--]]
==== `++constructor()++` [.item-kind]#public#

Constructor function.

[.contract-item]
[[App-getProvider-string-]]
==== `++getProvider(++[.var-type]#++string++#++ ++[.var-name]#++packageName++#++) → ++[.var-type]#++contract ImplementationProvider++#++ ++[.var-name]#++provider++#++++` [.item-kind]#public#

Returns the provider for a given package name, or zero if not set.


[.contract-item]
[[App-getPackage-string-]]
==== `++getPackage(++[.var-type]#++string++#++ ++[.var-name]#++packageName++#++) → ++[.var-type]#++contract Package++#++, ++[.var-type]#++uint64[3]++#++++` [.item-kind]#public#

Returns information on a package given its name.


[.contract-item]
[[App-setPackage-string-contract-Package-uint64-3--]]
==== `++setPackage(++[.var-type]#++string++#++ ++[.var-name]#++packageName++#++, ++[.var-type]#++contract Package++#++ ++[.var-name]#++package++#++, ++[.var-type]#++uint64[3]++#++ ++[.var-name]#++version++#++)++` [.item-kind]#public#

Sets a package in a specific version as a dependency for this application.
Requires the version to be present in the package.


[.contract-item]
[[App-unsetPackage-string-]]
==== `++unsetPackage(++[.var-type]#++string++#++ ++[.var-name]#++packageName++#++)++` [.item-kind]#public#

Unsets a package given its name.
Reverts if the package is not set in the application.


[.contract-item]
[[App-getImplementation-string-string-]]
==== `++getImplementation(++[.var-type]#++string++#++ ++[.var-name]#++packageName++#++, ++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#

Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.


[.contract-item]
[[App-create-string-string-address-bytes-]]
==== `++create(++[.var-type]#++string++#++ ++[.var-name]#++packageName++#++, ++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++, ++[.var-type]#++address++#++ ++[.var-name]#++admin++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++data++#++) → ++[.var-type]#++contract AdminUpgradeabilityProxy++#++++` [.item-kind]#public#

Creates a new proxy for the given contract and forwards a function call to it.
This is useful to initialize the proxied contract.



[.contract-item]
[[App-ProxyCreated-address-]]
==== `++ProxyCreated(++[.var-type]#++address++#++ ++[.var-name]#++proxy++#++)++` [.item-kind]#event#

Emitted when a new proxy is created.


[.contract-item]
[[App-PackageChanged-string-address-uint64-3--]]
==== `++PackageChanged(++[.var-type]#++string++#++ ++[.var-name]#++providerName++#++, ++[.var-type]#++address++#++ ++[.var-name]#++package++#++, ++[.var-type]#++uint64[3]++#++ ++[.var-name]#++version++#++)++` [.item-kind]#event#

Emitted when a package dependency is changed in the application.




:ImplementationDirectory: pass:normal[xref:#ImplementationDirectory[`++ImplementationDirectory++`]]
:whenNotFrozen: pass:normal[xref:#ImplementationDirectory-whenNotFrozen--[`++whenNotFrozen++`]]
:onlyOwner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-onlyOwner--[`++onlyOwner++`]]
:freeze: pass:normal[xref:#ImplementationDirectory-freeze--[`++freeze++`]]
:getImplementation: pass:normal[xref:#ImplementationDirectory-getImplementation-string-[`++getImplementation++`]]
:setImplementation: pass:normal[xref:#ImplementationDirectory-setImplementation-string-address-[`++setImplementation++`]]
:unsetImplementation: pass:normal[xref:#ImplementationDirectory-unsetImplementation-string-[`++unsetImplementation++`]]
:constructor: pass:normal[xref:#OpenZeppelinUpgradesOwnable-constructor--[`++constructor++`]]
:owner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-owner--[`++owner++`]]
:isOwner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-isOwner--[`++isOwner++`]]
:renounceOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-renounceOwnership--[`++renounceOwnership++`]]
:transferOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-transferOwnership-address-[`++transferOwnership++`]]
:_transferOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-_transferOwnership-address-[`++_transferOwnership++`]]
:ImplementationChanged: pass:normal[xref:#ImplementationDirectory-ImplementationChanged-string-address-[`++ImplementationChanged++`]]
:Frozen: pass:normal[xref:#ImplementationDirectory-Frozen--[`++Frozen++`]]
:OwnershipTransferred: pass:normal[xref:#OpenZeppelinUpgradesOwnable-OwnershipTransferred-address-address-[`++OwnershipTransferred++`]]

[.contract]
[[ImplementationDirectory]]
=== `++ImplementationDirectory++`

Implementation provider that stores contract implementations in a mapping.

[.contract-index]
.Modifiers
--
* xref:#ImplementationDirectory-whenNotFrozen--[`++whenNotFrozen()++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-onlyOwner--[`++onlyOwner()++`]

[.contract-subindex-inherited]
.ImplementationProvider

--

[.contract-index]
.Functions
--
* xref:#ImplementationDirectory-freeze--[`++freeze()++`]
* xref:#ImplementationDirectory-getImplementation-string-[`++getImplementation(contractName)++`]
* xref:#ImplementationDirectory-setImplementation-string-address-[`++setImplementation(contractName, implementation)++`]
* xref:#ImplementationDirectory-unsetImplementation-string-[`++unsetImplementation(contractName)++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-constructor--[`++constructor()++`]
* xref:#OpenZeppelinUpgradesOwnable-owner--[`++owner()++`]
* xref:#OpenZeppelinUpgradesOwnable-isOwner--[`++isOwner()++`]
* xref:#OpenZeppelinUpgradesOwnable-renounceOwnership--[`++renounceOwnership()++`]
* xref:#OpenZeppelinUpgradesOwnable-transferOwnership-address-[`++transferOwnership(newOwner)++`]
* xref:#OpenZeppelinUpgradesOwnable-_transferOwnership-address-[`++_transferOwnership(newOwner)++`]

[.contract-subindex-inherited]
.ImplementationProvider

--

[.contract-index]
.Events
--
* xref:#ImplementationDirectory-ImplementationChanged-string-address-[`++ImplementationChanged(contractName, implementation)++`]
* xref:#ImplementationDirectory-Frozen--[`++Frozen()++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-OwnershipTransferred-address-address-[`++OwnershipTransferred(previousOwner, newOwner)++`]

[.contract-subindex-inherited]
.ImplementationProvider

--

[.contract-item]
[[ImplementationDirectory-whenNotFrozen--]]
==== `++whenNotFrozen()++` [.item-kind]#modifier#

Modifier that allows functions to be called only before the contract is frozen.


[.contract-item]
[[ImplementationDirectory-freeze--]]
==== `++freeze()++` [.item-kind]#public#

Makes the directory irreversibly immutable.
It can only be called once, by the owner.

[.contract-item]
[[ImplementationDirectory-getImplementation-string-]]
==== `++getImplementation(++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#

Returns the implementation address of a contract.


[.contract-item]
[[ImplementationDirectory-setImplementation-string-address-]]
==== `++setImplementation(++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++, ++[.var-type]#++address++#++ ++[.var-name]#++implementation++#++)++` [.item-kind]#public#

Sets the address of the implementation of a contract in the directory.


[.contract-item]
[[ImplementationDirectory-unsetImplementation-string-]]
==== `++unsetImplementation(++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++)++` [.item-kind]#public#

Removes the address of a contract implementation from the directory.



[.contract-item]
[[ImplementationDirectory-ImplementationChanged-string-address-]]
==== `++ImplementationChanged(++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++, ++[.var-type]#++address++#++ ++[.var-name]#++implementation++#++)++` [.item-kind]#event#

Emitted when the implementation of a contract is changed.


[.contract-item]
[[ImplementationDirectory-Frozen--]]
==== `++Frozen()++` [.item-kind]#event#

Emitted when the implementation directory is frozen.



:ImplementationProvider: pass:normal[xref:#ImplementationProvider[`++ImplementationProvider++`]]
:getImplementation: pass:normal[xref:#ImplementationProvider-getImplementation-string-[`++getImplementation++`]]

[.contract]
[[ImplementationProvider]]
=== `++ImplementationProvider++`

Abstract contract for providing implementation addresses for other contracts by name.


[.contract-index]
.Functions
--
* xref:#ImplementationProvider-getImplementation-string-[`++getImplementation(contractName)++`]

--



[.contract-item]
[[ImplementationProvider-getImplementation-string-]]
==== `++getImplementation(++[.var-type]#++string++#++ ++[.var-name]#++contractName++#++) → ++[.var-type]#++address++#++++` [.item-kind]#public#

Abstract function to return the implementation address of a contract.





:Package: pass:normal[xref:#Package[`++Package++`]]
:onlyOwner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-onlyOwner--[`++onlyOwner++`]]
:getVersion: pass:normal[xref:#Package-getVersion-uint64-3--[`++getVersion++`]]
:getContract: pass:normal[xref:#Package-getContract-uint64-3--[`++getContract++`]]
:addVersion: pass:normal[xref:#Package-addVersion-uint64-3--address-bytes-[`++addVersion++`]]
:hasVersion: pass:normal[xref:#Package-hasVersion-uint64-3--[`++hasVersion++`]]
:getLatest: pass:normal[xref:#Package-getLatest--[`++getLatest++`]]
:getLatestByMajor: pass:normal[xref:#Package-getLatestByMajor-uint64-[`++getLatestByMajor++`]]
:semanticVersionHash: pass:normal[xref:#Package-semanticVersionHash-uint64-3--[`++semanticVersionHash++`]]
:semanticVersionIsZero: pass:normal[xref:#Package-semanticVersionIsZero-uint64-3--[`++semanticVersionIsZero++`]]
:constructor: pass:normal[xref:#OpenZeppelinUpgradesOwnable-constructor--[`++constructor++`]]
:owner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-owner--[`++owner++`]]
:isOwner: pass:normal[xref:#OpenZeppelinUpgradesOwnable-isOwner--[`++isOwner++`]]
:renounceOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-renounceOwnership--[`++renounceOwnership++`]]
:transferOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-transferOwnership-address-[`++transferOwnership++`]]
:_transferOwnership: pass:normal[xref:#OpenZeppelinUpgradesOwnable-_transferOwnership-address-[`++_transferOwnership++`]]
:VersionAdded: pass:normal[xref:#Package-VersionAdded-uint64-3--address-bytes-[`++VersionAdded++`]]
:OwnershipTransferred: pass:normal[xref:#OpenZeppelinUpgradesOwnable-OwnershipTransferred-address-address-[`++OwnershipTransferred++`]]

[.contract]
[[Package]]
=== `++Package++`

A package is composed by a set of versions, identified via semantic versioning,
where each version has a contract address that refers to a reusable implementation,
plus an optional content URI with metadata. Note that the semver identifier is restricted
to major, minor, and patch, as prerelease tags are not supported.

[.contract-index]
.Modifiers
--

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-onlyOwner--[`++onlyOwner()++`]

--

[.contract-index]
.Functions
--
* xref:#Package-getVersion-uint64-3--[`++getVersion(semanticVersion)++`]
* xref:#Package-getContract-uint64-3--[`++getContract(semanticVersion)++`]
* xref:#Package-addVersion-uint64-3--address-bytes-[`++addVersion(semanticVersion, contractAddress, contentURI)++`]
* xref:#Package-hasVersion-uint64-3--[`++hasVersion(semanticVersion)++`]
* xref:#Package-getLatest--[`++getLatest()++`]
* xref:#Package-getLatestByMajor-uint64-[`++getLatestByMajor(major)++`]
* xref:#Package-semanticVersionHash-uint64-3--[`++semanticVersionHash(version)++`]
* xref:#Package-semanticVersionIsZero-uint64-3--[`++semanticVersionIsZero(version)++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-constructor--[`++constructor()++`]
* xref:#OpenZeppelinUpgradesOwnable-owner--[`++owner()++`]
* xref:#OpenZeppelinUpgradesOwnable-isOwner--[`++isOwner()++`]
* xref:#OpenZeppelinUpgradesOwnable-renounceOwnership--[`++renounceOwnership()++`]
* xref:#OpenZeppelinUpgradesOwnable-transferOwnership-address-[`++transferOwnership(newOwner)++`]
* xref:#OpenZeppelinUpgradesOwnable-_transferOwnership-address-[`++_transferOwnership(newOwner)++`]

--

[.contract-index]
.Events
--
* xref:#Package-VersionAdded-uint64-3--address-bytes-[`++VersionAdded(semanticVersion, contractAddress, contentURI)++`]

[.contract-subindex-inherited]
.OpenZeppelinUpgradesOwnable
* xref:#OpenZeppelinUpgradesOwnable-OwnershipTransferred-address-address-[`++OwnershipTransferred(previousOwner, newOwner)++`]

--


[.contract-item]
[[Package-getVersion-uint64-3--]]
==== `++getVersion(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++) → ++[.var-type]#++address++#++ ++[.var-name]#++contractAddress++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++contentURI++#++++` [.item-kind]#public#

Returns a version given its semver identifier.


[.contract-item]
[[Package-getContract-uint64-3--]]
==== `++getContract(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++) → ++[.var-type]#++address++#++ ++[.var-name]#++contractAddress++#++++` [.item-kind]#public#

Returns a contract for a version given its semver identifier.
This method is equivalent to `getVersion`, but returns only the contract address.


[.contract-item]
[[Package-addVersion-uint64-3--address-bytes-]]
==== `++addVersion(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++, ++[.var-type]#++address++#++ ++[.var-name]#++contractAddress++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++contentURI++#++)++` [.item-kind]#public#

Adds a new version to the package. Only the Owner can add new versions.
Reverts if the specified semver identifier already exists. 
Emits a `VersionAdded` event if successful.


[.contract-item]
[[Package-hasVersion-uint64-3--]]
==== `++hasVersion(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++) → ++[.var-type]#++bool++#++++` [.item-kind]#public#

Checks whether a version is present in the package.


[.contract-item]
[[Package-getLatest--]]
==== `++getLatest() → ++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++, ++[.var-type]#++address++#++ ++[.var-name]#++contractAddress++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++contentURI++#++++` [.item-kind]#public#

Returns the version with the highest semver identifier registered in the package.
For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless 
of the order in which they were registered. Returns zero if no versions are registered.


[.contract-item]
[[Package-getLatestByMajor-uint64-]]
==== `++getLatestByMajor(++[.var-type]#++uint64++#++ ++[.var-name]#++major++#++) → ++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++, ++[.var-type]#++address++#++ ++[.var-name]#++contractAddress++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++contentURI++#++++` [.item-kind]#public#

Returns the version with the highest semver identifier for the given major.
For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, 
regardless of the order in which they were registered. Returns zero if no versions are registered
for the specified major.


[.contract-item]
[[Package-semanticVersionHash-uint64-3--]]
==== `++semanticVersionHash(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++version++#++) → ++[.var-type]#++bytes32++#++++` [.item-kind]#internal#



[.contract-item]
[[Package-semanticVersionIsZero-uint64-3--]]
==== `++semanticVersionIsZero(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++version++#++) → ++[.var-type]#++bool++#++++` [.item-kind]#internal#




[.contract-item]
[[Package-VersionAdded-uint64-3--address-bytes-]]
==== `++VersionAdded(++[.var-type]#++uint64[3]++#++ ++[.var-name]#++semanticVersion++#++, ++[.var-type]#++address++#++ ++[.var-name]#++contractAddress++#++, ++[.var-type]#++bytes++#++ ++[.var-name]#++contentURI++#++)++` [.item-kind]#event#

Emitted when a version is added to the package.




== Utility

:Initializable: pass:normal[xref:#Initializable[`++Initializable++`]]
:initializer: pass:normal[xref:#Initializable-initializer--[`++initializer++`]]

[.contract]
[[Initializable]]
=== `++Initializable++`

Helper contract to support initializer functions. To use it, replace
the constructor with a function that has the `initializer` modifier.
WARNING: Unlike constructors, initializer functions must be manually
invoked. This applies both to deploying an Initializable contract, as well
as extending an Initializable contract via inheritance.
WARNING: When used with inheritance, manual care must be taken to not invoke
a parent initializer twice, or ensure that all initializers are idempotent,
because this is not dealt with automatically as with constructors.

[.contract-index]
.Modifiers
--
* xref:#Initializable-initializer--[`++initializer()++`]

--



[.contract-item]
[[Initializable-initializer--]]
==== `++initializer()++` [.item-kind]#modifier#

Modifier to use in the initializer function of a contract.




